diff -urNp coreutils-8.4-orig/tests/dd/sparse coreutils-8.4/tests/dd/sparse
--- coreutils-8.4-orig/tests/dd/sparse	2014-05-05 14:53:32.445465358 +0200
+++ coreutils-8.4/tests/dd/sparse	2014-05-05 15:08:07.274620813 +0200
@@ -46,19 +46,36 @@ compare exp out || fail=1
 dd if=file.in bs=1 conv=sparse | cat > file.out
 cmp file.in file.out || fail=1
 
-# Setup for block size tests
-dd if=/dev/urandom of=file.in bs=1M count=1
-truncate -s+1M file.in
-dd if=/dev/urandom of=file.in bs=1M count=1 conv=notrunc oflag=append
-
-# Ensure NUL blocks smaller than the block size are not made sparse
-dd if=file.in of=file.out bs=2M conv=sparse
-test $(stat -c %s file.in) = $(stat -c %s file.out) || fail=1
-test $(stat -c %b file.in) = $(stat -c %b file.out) && fail=1
-
-# Ensure NUL blocks >= block size are made sparse
-dd if=file.in of=file.out bs=1M conv=sparse
-test $(stat -c %s file.in) = $(stat -c %s file.out) || fail=1
-test $(stat -c %b file.in) = $(stat -c %b file.out) || fail=1
+# Setup for block size tests: create a 3MiB file with a 1MiB
+# stretch of NUL bytes in the middle.
+rm -f file.in
+dd if=/dev/urandom of=file.in bs=1M count=3 iflag=fullblock || fail=1
+dd if=/dev/zero of=file.in bs=1M count=1 seek=1 conv=notrunc || fail=1
+
+kb_alloc() { du -k "$1"|cut -f1; }
+
+# If our just-created input file appears to be too small,
+# skip the remaining tests. On at least Solaris 10 with NFS,
+# file.in is reported to occupy <= 1KiB for about 50 seconds
+# after its creation.
+if test $(kb_alloc file.in) -gt 3000; then
+
+ # Ensure NUL blocks smaller than the block size are not made sparse.
+ # Here, with a 2MiB block size, dd's conv=sparse must *not* introduce a hole.
+ dd if=file.in of=file.out bs=2M conv=sparse
+ test 2500 -lt $(kb_alloc file.out) || fail=1
+
+ # Note we recreate a sparse file first to avoid
+ # speculative preallocation seen in XFS, where a write() that
+ # extends a file can preallocate some extra space that
+ # a subsequent seek will not convert to a hole.
+ rm -f file.out
+ truncate --size=3M file.out
+
+ # Ensure that this 1MiB string of NULs *is* converted to a hole.
+ dd if=file.in of=file.out bs=1M conv=sparse,notrunc
+ test $(kb_alloc file.out) -lt 2500 || fail=1
+
+fi
 
 Exit $fail
